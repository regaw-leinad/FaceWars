<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>sandbox</title>
	<style type="text/css" media="screen">
		.point {
			width: 0;
			height: 0;
			position: absolute;
			top: 50%;
			left: 50%;
		}
		.ship {
			width: 50px;
			height: 50px;
			position: absolute;
			z-index: 10;
			top: 50%;
			left: 50%;
			margin-top: -25px;
			margin-left: -25px;
			border-radius: 100px;
		}
	</style>
</head>
<body>

<script type="text/javascript">



	$(window).bind('beforeunload', function(eventObject) {
	    socket.emit(Packet.USER_DISCONNECTING, { user: currentUser });
	});


	var Packet = {
	    USER_AUTH_NEW: 0,
	    USER_AUTH_RESPONSE: 1,
	    USER_JOIN_SESSION: 2,
	    USER_LEAVE_SESSION: 3,
	    USER_DISCONNECTING: 4,
	    UPDATE_ENTITY: 5
	};






	var EntityType = {
		SHIP: 0,
		PROJECTILE: 1
	};



	var entitiesByID = {};
	var ownProjectilesById = {};
	var ownShipEntity;

	var currentUser = {
		id: undefined,
		name: undefined,
		color: undefined
	};

	var currentSession = {
		id: undefined,
		users: []
	};

	var entityExample = {
		userName: undefined,
		elementId: undefined,
		type: undefined,
		x: undefined,
		y: undefined,
		dx: undefined,
		dy: undefined,
		speed: undefined,
		shipRotation: undefined,
		moveRotation: undefined
	};



	var socket = io.connect('http://localhost:1234');

	socket.on(Packet.USER_AUTH_RESPONSE, function (data) {
		if (data.err) {
			console.error(data.err);
			return;
		}

		currentUser = data.user;
		currentSession = data.session;

		console.log('auth success');
		console.log(currentUser);
		console.log(currentSession);

		ownShipEntity = new Ship(Ship.createNewDataFromUser(currentUser));
		entitiesByID[ownShipEntity.getId()] = ownShipEntity;

	});

	socket.emit(Packet.USER_AUTH_NEW, {
		userName: salt(10),
		color: '#' + Math.floor(Math.random() * 16777215).toString(16)
	});


	socket.on(Packet.UPDATE_ENTITY, function (entityModel) {
		if (entitiesByID[entityModel.id]) {
			if (entityModel.type === EntityType.SHIP) {
				entitiesByID[entityModel.id].update(entityModel);
			}
		} else {
			entitiesByID[entityModel.id] = new Ship(entityModel);
		}
	});





	function Ship(data) {
		
		this.m = {};
		this.m.id = data.id;
		this.m.color = data.color;
		this.m.userName = data.userName;
		this.m.x = data.x;
		this.m.y = data.y;
		this.m.type = data.type;
		
		this.el = {};
		this.el.point = document.createElement('div');
		this.el.point.setAttribute('id', this.m.id);
		this.el.point.setAttribute('class', 'point');
		this.el.ship = document.createElement('div');
		this.el.ship.setAttribute('class', 'ship');
		this.el.ship.style.backgroundColor = this.m.color;
		
		this.el.point.appendChild(this.el.ship);
		document.body.appendChild(this.el.point);

		this.draw();

	}

	Ship.createNewDataFromUser = function (user) {
		var data = {};
		data.id = (new Date()).getTime() + '-' + salt();
		data.color = user.color;
		data.userName = user.name;
		data.x = Math.round(Math.random() * window.innerWidth);
		data.y = Math.round(Math.random() * window.innerWidth);
		data.type = EntityType.SHIP;
		return data;
	};

	Ship.prototype.draw = function () {
		this.el.point.style.left = this.m.x + 'px';
		this.el.point.style.top = this.m.y + 'px';
	};

	Ship.prototype.update = function (model) {
		this.m = model;
		this.draw();
	};

	Ship.prototype.getModel = function () {
		return this.m;
	};

	Ship.prototype.getType = function () {
		return this.m.type;
	};

	Ship.prototype.getId = function () {
		return this.m.id;
	};

	Ship.prototype.moveX = function(dx) {
		this.m.x += dx;
	};

	Ship.prototype.moveY = function(dy) {
		this.m.y += dy;
	};

	Ship.prototype.setColor = function(color) {
		this.m.color = color;
	};








	var Keys = (function () {
		// state maps { keyCode: boolean }
		var keyIsDown = {};
		var keyIsPressed = {};
		var keyPressLimbo = {};
		// handle key down
		window.addEventListener('keydown', function (e) {
			var key = e.keyCode || e.which;
			keyIsDown[key] = true;
			if (!keyPressLimbo[key]) {
				keyIsPressed[key] = true;
				keyPressLimbo[key] = true;
			}
		});
		// handle key up
		window.addEventListener('keyup', function (e) {
			var key = e.keyCode || e.which;
			if (keyIsDown[key]) {
				delete keyIsDown[key];
			}
			if (keyPressLimbo[key]) {
				delete keyPressLimbo[key];
			}
		});
		// public interface
		return {
			// update on frame
			update: function () {
				/*
				Object.keys(keyIsDown).forEach(function (keyCode) {
					console.log('downed keyCode = ' + keyCode);
				});
				Object.keys(keyIsPressed).forEach(function (keyCode) {
					console.log('pressed keyCode = ' + keyCode);
				});
				*/
				// reset presses
				keyIsPressed = {};
			},
			// state check methods
			isDown: function (keyCode) {
				return keyIsDown[keyCode];
			},
			isPressed: function (keyCode) {
				if (keyIsPressed[keyCode]) {
					delete keyIsPressed[keyCode];
					return true;
				} else {
					return false;
				}
			},
			// keycodes
			SPACEBAR: 32,
			LEFT: 37,
			UP: 38,
			RIGHT: 39,
			DOWN: 40
		};
	})();




	function handleMovement(dt) {
		if (!ownShipEntity) return;
		var ship = ownShipEntity;

		console.log(dt);

		var speed = 100 / dt;
		var slowdown = 3 / 4;
		// up left
		if (Keys.isDown(Keys.UP) && Keys.isDown(Keys.LEFT)) {
			speed = speed * slowdown;
			ship.moveX(-speed);
			ship.moveY(-speed);
		}
		// up right
		else if (Keys.isDown(Keys.UP) && Keys.isDown(Keys.RIGHT)) {
			speed = speed * slowdown;
			ship.moveX(speed);
			ship.moveY(-speed);
		}
		// down left
		else if (Keys.isDown(Keys.DOWN) && Keys.isDown(Keys.LEFT)) {
			speed = speed * slowdown;
			ship.moveX(-speed);
			ship.moveY(speed);
		}
		// down right
		else if (Keys.isDown(Keys.DOWN) && Keys.isDown(Keys.RIGHT)) {
			speed = speed * slowdown;
			ship.moveX(speed);
			ship.moveY(speed);
		}
		else {
			// left
			if (Keys.isDown(Keys.LEFT)) {
				ship.moveX(-speed);
			}
			// right
			if (Keys.isDown(Keys.RIGHT)) {
				ship.moveX(speed);
			}
			// up
			if (Keys.isDown(Keys.UP)) {
				ship.moveY(-speed);
			}
			// down
			if (Keys.isDown(Keys.DOWN)) {
				ship.moveY(speed);
			}
		}
	}




	// handle frame 
	function onFrame(time) {

		var dt = time - onFrame.oldTime;

		handleMovement(dt);

		if (ownShipEntity) {
			socket.emit(
				Packet.UPDATE_ENTITY, 
				ownShipEntity.getModel()
			);
		}

		Object.keys(ownProjectilesById).forEach(function (key) {
			socket.emit(
				Packet.UPDATE_ENTITY, 
				ownProjectilesById[key].getModel()
			);
		});

		Keys.update();
		requestAnimationFrame(onFrame);
	}
	// start frame handling
	onFrame.oldTime = (new Date()).getTime();
	requestAnimationFrame(onFrame);




</script>
</body>
</html>